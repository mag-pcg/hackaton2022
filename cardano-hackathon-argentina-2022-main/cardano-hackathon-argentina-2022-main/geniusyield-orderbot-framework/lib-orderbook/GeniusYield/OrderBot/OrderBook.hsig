{- |
Module: GeniusYield.OrderBot.OrderBook
Synopsis: The public query-focused interface of an opaque 'OrderBook' data structure.
Description: These are the queries _we think_ most order matching strategies
will make in order to perform the order matching task. New queries can be
added of course, but whether or not new queries will be efficient depends entirely on
the implementation under the hood.

For now, the most common "order matching queries" are exported in this module, as well utilities
to construct the order book.
-}
signature GeniusYield.OrderBot.OrderBook (
    -- * Core Order book types
    MultiAssetOrderBook,
    OrderBook,
    -- * Order book components
    Orders,
    LiquidityPositions,
    buyOrders,
    sellOrders,
    liquidityPositions,
    -- * Order book construction
    populateOrderBook,
    -- * Order book queries
    lowestSell,
    highestBuy,
    withoutTip,
    foldlOrders,
    foldrOrders,
    ordersLTPrice,
    ordersLTEPrice,
    ordersGTPrice,
    ordersGTEPrice,
    volumeLTPrice,
    volumeLTEPrice,
    volumeGTPrice,
    volumeGTEPrice,
    -- * MultiAssetOrderBook reading utilities
    withEachAsset
) where

import           Prelude                           (IO, Bool)

import           Data.Kind                         (Type)

import           GeniusYield.Types                 (GYAssetClass)
import           GeniusYield.OrderBot.Types        (OrderAssetPair, OrderType (BuyOrder, SellOrder),
                                                    OrderInfo, Price, Volume)
import           GeniusYield.OrderBot.DataSource   (Connection)

-------------------------------------------------------------------------------
-- Core Order book types
-------------------------------------------------------------------------------

{- | In a DEX, with the existence of many possible asset pairings, an order book is really
a collection of several orderbooks - all belonging to specific token pairings.
-}
data MultiAssetOrderBook

{- | The "Order book", in the context of the order matching bot, is a data source
that can efficiently answer queries like:
1. What are the intersecting buy and sell orders?
2. What is the max bid?
3. What is the min ask?

etc.
-}
data OrderBook

-------------------------------------------------------------------------------
-- Order book components
-------------------------------------------------------------------------------

-- | The simple and partial DEX orders for a particular 'OrderAssetPair'.
type Orders :: OrderType -> Type
data Orders t

-- | The DEX liquidity positions available to be matched with orders.
data LiquidityPositions

-------------------------------------------------------------------------------
-- Order book population related interfaces
-------------------------------------------------------------------------------

{- | Given a DB connection to a database holding information about GY DEX orders on the blockchain,
return a populated OrderBook.

Also takes in a function to filter uninteresting orders. This should be passed to the datasource function(s).

The 'OrderBot.DataSource' signature also exposes functions to query buy orders, sell orders, and
liquidity positions. This implementation may use those as necessary.
-}
populateOrderBook :: Connection -> (GYAssetClass -> Bool) -> IO MultiAssetOrderBook

-------------------------------------------------------------------------------
-- Order book queries
-------------------------------------------------------------------------------

-- Components

buyOrders :: OrderBook -> Orders 'BuyOrder

sellOrders :: OrderBook -> Orders 'SellOrder

liquidityPositions :: OrderBook -> LiquidityPositions

-- Minima & Maxima

lowestSell :: Orders 'SellOrder -> OrderInfo 'SellOrder

highestBuy :: Orders 'BuyOrder -> OrderInfo 'BuyOrder

-- Slicing

withoutTip :: Orders t -> Orders t

-- Folds

{- | Left associative fold over the 'Orders' data structure.

The order in which each 'OrderInfo' is passed onto the function, depends on the type of
'Orders'.

For sell orders, it should act like a 'foldr' on a list with _ascending_ orders based on price.
For buy orders, it should act like a 'foldr' on a list with _descending_ orders based on price.
-}
foldlOrders :: forall a t. (a -> OrderInfo t -> a) -> a -> Orders t -> a

{- | Right associative fold over the 'Orders' data structure.

The order in which each 'OrderInfo' is passed onto the function, depends on the type of
'Orders'.

For sell orders, it should act like a 'foldl' on a list with _ascending_ orders based on price.
For buy orders, it should act like a 'foldl' on a list with _descending_ orders based on price.
-}
foldrOrders :: forall a t. (OrderInfo t -> a -> a) -> a -> Orders t -> a

-- Price queries

ordersLTPrice :: Price -> Orders t -> Orders t

ordersLTEPrice :: Price -> Orders t -> Orders t

ordersGTPrice :: Price -> Orders t -> Orders t

ordersGTEPrice :: Price -> Orders t -> Orders t

-- Volume queries

volumeLTPrice :: Price -> Orders t -> Volume

volumeLTEPrice :: Price -> Orders t -> Volume

volumeGTPrice :: Price -> Orders t -> Volume

volumeGTEPrice :: Price -> Orders t -> Volume

-------------------------------------------------------------------------------
-- MultiAssetOrderBook reading utilities
-------------------------------------------------------------------------------

withEachAsset :: (OrderAssetPair -> OrderBook -> [a]) -> MultiAssetOrderBook -> [a]
